%% FUNCTION NAME: BB84LossyNoisyChannel
% Lossy and noisy channel model for prepare-and-measure BB84. 
% Parameters:
% Transmitance eta, bitflip angle theta, phaseflip angle phi
%%

function channelModel = BB84Channel1(protocolDescription,names,p)

    %user should supply the list of parameters used in this description/channel file
    %this list varNames should be a subset of the full parameter list declared in the preset file
    %parameters specified in varNames can be used below like any other MATLAB variables
    varNames=["loss","fullstat", "a", "eta0", "delta", "theta", "phi"];
    %varNames=["loss","fullstat", "a", "eta0", "num_pts", "phi"];
    %varNames=["loss","fullstat", "a", "num_pts"];
    
    %%%%%%%%%%%%%%%%%%%%% interfacing (please do not modify) %%%%%%%%%%%%%%%%%%%%%%%%%
    
    %the functions findVariables and addVariables automatically search the input (names,p) for
    %the parameter values based on varNames, and convert them to MATLAB variables.
    varValues = findVariables(varNames,names,p);
    addVariables(varNames,varValues);
    
    %allocate the outputs of this channel model file
    %can be automatically filled in by calling addExpectations(x) or addExpectations(x,'mask',maskValue)
    expectations = [];
    expMask = [];
    
    %%%%%%%%%%%%%%%%%%%%% user-supplied channel model begin %%%%%%%%%%%%%%%%%%%%%%%%%

    dimA = protocolDescription.dimensions(1);
    dimB = protocolDescription.dimensions(2);
    dimPB = 5;
    eta = 10^(-0.1*loss);  % transmissivity
    b = sqrt(1-a^2);
    signalStates = {[1;0], [0; 1], [a;b], [b;-a]};  % 4 states
    probList = [1/4; 1/4; 1/4; 1/4];
    
    % rho_A constraints
    rhoA = zeros(dimA);
    %partial trace over flying qubit system to obtain local rhoA
    for jRow = 1 : dimA
        for kColumn = 1 : dimA
            rhoA(jRow,kColumn) = sqrt(probList(jRow) * probList(kColumn)) * signalStates{kColumn}' * signalStates{jRow};
        end
    end
    basis = hermitianBasis(dimA);
    for iBasisElm = 1 : length(basis)
        addExpectations(trace(basis{iBasisElm}' * rhoA),'mask',0);
    end
    
    % Normalization
    addExpectations(1,'mask',0);
    
    % lossy channel
    rho_in = 0.25*kron(diag([1, 0, 0, 0]),diag([1, 0, 0])) ...
    + 0.25*kron(diag([0,1,0,0]), diag([0,1,0])) ...
    + 0.25*kron(diag([0,0,1,0]), [a^2,a*b,0 ;a*b,b^2,0; 0,0,0]) ...
    + 0.25*kron(diag([0,0,0,1]), [b^2,-a*b,0; -a*b,a^2,0; 0,0,0]) ; % 4 states
    
    % Noise unitary, misalignment
    U1 = [cos(theta), -exp(-1i*phi)*sin(theta); 
        exp(1i*phi)*sin(theta), cos(theta)];

    U = kron(diag([1,1,1,1]),blkdiag(U1, [1]));

    % one photon protocol
    rho_in2 = eta^1*(U*rho_in*U') + (1-eta^1)*kron(diag([1,1,1,1])/4,diag([0,0,1]));


    % mode-dependent loss, channel1 according to Hannah's notes
    E0 = kron(eye(4), [0,0,0;0,0,0;0,sqrt(1-eta0),0]);
    E1 = kron(eye(4), diag([1, sqrt(eta0)*exp(1i*delta), 1]));
    rho_out = E0 * rho_in2 * E0' + E1 * rho_in2 * E1';

    % mode-dependent loss, channel1 according to Hannah's notes
    E0 = kron(eye(4), [0,0,0;0,0,0;sqrt(1-eta0),0,0]);
    E1 = kron(eye(4), diag([sqrt(eta0), 1, 1]));
    rho_out = E0 * rho_in2 * E0' + E1 * rho_in2 * E1';

   
    % % Mixed U channel
    % theta_vec = linspace(0,2*pi,num_pts+1);
    % p_theta = 1/num_pts;
    % 
    % rho_out = (1-eta)*kron(diag([1,1,1,1])/4,diag([0,0,1]));
    % 
    % for i=1:num_pts
    %     U1 = [cos(theta_vec(i)), -sin(theta_vec(i))*exp(-1i*phi);
    %         sin(theta_vec(i))*exp(1i*phi), cos(theta_vec(i))];
    % 
    %     U = kron(diag([1,1,1,1]),blkdiag(U1, [1]));
    % 
    %     rho_out = rho_out + eta*(U*rho_in*U')*p_theta;
    % end


    % Mixed amplitude damping channel 
    %input eta0 and delta for each theta=0 and phi=0 for our protocol with tau1 = 0ps,
    %tau2 = 220ps, sigma_t = 17ps, Omega1 =0 offset, Omega2 = 0.019 THz,
    %sigma_w = 0.5 GHz
    %data generated by python code of measurement probability for phi = 0
    %for varying theta angles equally spaced between 0 and 2pi
    % eta0_vec = csvread("C:\Users\ir22317\OneDrive - University of Bristol\PhD\Noiseless QKD Project\Security Analysis\meas_probs_500MHz_phi0.csv");
    % delta_vec = csvread("C:\Users\ir22317\OneDrive - University of Bristol\PhD\Noiseless QKD Project\Security Analysis\meas_phases_500MHz_phi0.csv");
    % theta_vec = csvread("C:\Users\ir22317\OneDrive - University of Bristol\PhD\Noiseless QKD Project\Security Analysis\500MHz_phi0_thetas.csv");
    % 
    % theta_gen = linspace(0,2*pi, num_pts+1);
    % eta0_out = interp1(theta_vec, eta0_vec, theta_gen, 'spline');
    % delta_out = interp1(theta_vec, delta_vec, theta_gen, 'spline');
    % p_theta = 1/num_pts;
    % 
    % rho_out = 0;
    % 
    % for i=1:num_pts
    %     E0 = kron(eye(4), [0,0,0;0,0,0;sqrt(1-eta0_out(i)),0,0]);
    %     E1 = kron(eye(4), diag([1, sqrt(eta0_out(i))*exp(1i*delta_out(i)), 1]));
    %     rho_out = rho_out + p_theta*(E0 * rho_in * E0' + E1 * rho_in * E1');
    % end

    % 
    % eta0_vec = csvread("C:\Users\ir22317\OneDrive - University of Bristol\PhD\Noiseless QKD Project\Security Analysis\meas_probs_500MHz_phi0.csv");
    % delta_vec = csvread("C:\Users\ir22317\OneDrive - University of Bristol\PhD\Noiseless QKD Project\Security Analysis\meas_phases_500MHz_phi0.csv");
    % theta_vec = csvread("C:\Users\ir22317\OneDrive - University of Bristol\PhD\Noiseless QKD Project\Security Analysis\500MHz_phi0_thetas.csv");
    % 
    % theta_gen = linspace(0,2*pi, num_pts+1);
    % eta0_out = interp1(theta_vec, eta0_vec, theta_gen, 'spline');
    % delta_out = interp1(theta_vec, delta_vec, theta_gen, 'spline');
    % p_theta = 1/num_pts;
    % 
    % rho_out = 0;
    % 
    % % E0 = kron(eye(4), [0,0,0;0,0,0;sqrt(1-eta0),0,0]);
    % % E1 = kron(eye(4), diag([sqrt(eta0), 1, 1]));
    % 
    % for i=1:num_pts
    %     E0 = kron(eye(4), [0,0,0;0,0,0;0,sqrt(1-eta0_out(i)),0]);
    %     E1 = kron(eye(4), diag([1, sqrt(eta0_out(i))*exp(1i*delta_out(i)), 1]));
    %     rho_out = rho_out + p_theta*(E0 * rho_in * E0' + E1 * rho_in * E1');
    % end
    % 



    
    basicBobPOVMs = {0.5*diag([1,0,0]), ...
        0.5*diag([0,1,0]),...
        0.5*[a^2,a*b,0;a*b,b^2,0;0,0,0], ...
        0.5*[b^2,-a*b,0;-a*b,a^2,0;0,0,0], ...
        diag([0,0,1])};
    basicAlicePOVMs = {diag([1,0,0,0]),diag([0,1,0,0]), diag([0,0,1,0]), diag([0,0,0,1])};
    %Full set of bipartite POVMS
    for i = 1:dimA
        for j = 1:dimPB
            POVM=kron(basicAlicePOVMs{i},basicBobPOVMs{j});
            Y1_simulation(i,j)=real(trace(POVM'*rho_out));
        end
    end
    

    bipartiteExpectations = Y1_simulation;  % stats from simulation
    bipartiteExpectations_1D = zeros(dimA*dimPB,1);
    for i = 1:dimA
        for j = 1:dimPB
            bipartiteExpectations_1D(dimPB*(i-1)+(j-1)+1) = bipartiteExpectations(i,j);
        end
    end
    
    
    if(fullstat==1)
        %fine-grain statistics
        addExpectations(bipartiteExpectations_1D,'mask',1);
    else
        %QBER and Gain statistics
        select=@(x,y)dimPB*(x-1)+(y-1)+1;
        %     expectations = [expectations; bipartiteExpectations_1D(select(1,2));bipartiteExpectations_1D(select(2,1));bipartiteExpectations_1D(select(3,4));bipartiteExpectations_1D(select(4,3))];
        coarseGrainExpectations = [bipartiteExpectations_1D(select(1,2));bipartiteExpectations_1D(select(2,1));bipartiteExpectations_1D(select(1,1));bipartiteExpectations_1D(select(2,2));...
        bipartiteExpectations_1D(select(3,4));bipartiteExpectations_1D(select(4,3));bipartiteExpectations_1D(select(3,3));bipartiteExpectations_1D(select(4,4))];
        addExpectations(coarseGrainExpectations,'mask',1);
        %normalization
        temp = sum([bipartiteExpectations_1D(select(1,2));bipartiteExpectations_1D(select(2,1));bipartiteExpectations_1D(select(1,1));bipartiteExpectations_1D(select(2,2));...
        bipartiteExpectations_1D(select(3,4));bipartiteExpectations_1D(select(4,3));bipartiteExpectations_1D(select(3,3));bipartiteExpectations_1D(select(4,4))]);
        addExpectations(1-temp,'mask',1);
    end
    
    % 4 states
    gain=sum(Y1_simulation.*[1,1,0,0,0; 1,1,0,0,0; 0,0,1,1,0; 0,0,1,1,0],'all');
    error=sum(Y1_simulation.*[0,1,0,0,0; 1,0,0,0,0; 0,0,1,0,0; 0,0,0,1,0],'all')/gain;


    
    % my_proba_dist = Y1_simulation(1:2,1:2,1);
    % psift=sum(sum(my_proba_dist));
    % 
    % %channelModel.errorRate = [error]; % to compute EC based on qber
    % channelModel.probDist = my_proba_dist/psift; % to compute EC on dist


    my_proba_dist_z = Y1_simulation(1:2,1:2,1);
    psift_z=sum(sum(my_proba_dist_z));

    my_proba_dist_x = Y1_simulation(3:4,3:4,1);
    psift_x=sum(sum(my_proba_dist_x));

    %channelModel.errorRate = [error]; % to compute EC based on qber
    channelModel.probDist = {my_proba_dist_z/psift_z, my_proba_dist_x/psift_x}; % to compute EC on dist
    
    
    %%%%%%%%%%%%%%%%%%%%% user-supplied channel model end %%%%%%%%%%%%%%%%%%%%%%%%%

    channelModel.expectations = expectations;
    channelModel.expMask = expMask;
    
    % channelModel.pSift = [gain];  % to compute EC based on qber
    channelModel.pSift = [psift_z, psift_x];  % EC based on proba dist
end
